import serial
import threading
import time


class serialESP32:
    def __init__(self, port, baudrate=9600, timeout=1, n_vars=1):
        """Initialize the SerialReader instance.

        Args:
            port (str): The serial port to connect to (e.g., 'COM3' or '/dev/ttyUSB0').
            baudrate (int): The baud rate for communication (default is 9600).
            timeout (int): Timeout for serial read operation (default is 1 second).
        """
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.serial_port = None
        self.reading_active = False
        self.read_thread = None
        self.n_vars = n_vars
        self.raw_data = [None]*self.n_vars

    def read_serial_data(self):
        """Internal method to read data from the serial port."""
        while self.reading_active:
            if self.serial_port.in_waiting > 0:  # Check if data is available
                decoded_data = self.serial_port.readline().decode('utf-8').strip()  # Decode and strip newline characters

                # Split the received data by commas
                data_list = decoded_data.split(',')

                # Optionally, print each part of the received data
                print("Receiving data.")

                # Example: Process each item in the list
                for k in range(self.n_vars):

                    self.raw_data[k] = float(data_list[k])

            time.sleep(0.1)  # Small delay to prevent busy-waiting

    def write_serial_data(self, data=None):
        """Internal method to send data (number) to the serial port."""
        while self.reading_active:
            if data is not None:
                # Send the message to the serial port (convert number to string)
                self.serial_port.write(f"{data}\n".encode('utf-8'))  # Send the number as a string
                print(f"Sending: {data}")
                # print("Sending data.")
                break  # Stop after sending one number
            time.sleep(0.1)
    
    def start(self):
        """Start the serial reading thread."""
        try:
            # Initialize the serial connection
            self.serial_port = serial.Serial(self.port, self.baudrate, timeout=self.timeout)
            print(f"Opened serial port {self.port} with baudrate {self.baudrate}")

            # Start the reading thread
            self.reading_active = True
            self.read_thread = threading.Thread(target=self.read_serial_data)
            self.read_thread.daemon = True  # Daemon thread will exit when the program ends
            self.read_thread.start()

            # Start the writing thread
            # self.write_thread = threading.Thread(target=self.write_serial_data, args=(data,))
            # self.write_thread.daemon = True  # Daemon thread will exit when the program ends
            # self.write_thread.start()

            # Wait for the writing thread to finish (if message is given)
            # if self.write_thread is not None:
            #     self.write_thread.join()

        except Exception as e:
            print(f"Error opening serial port: {e}")

    def stop(self):
        """Stop the serial communication and threads."""
        self.reading_active = False

        if self.serial_port:
            self.serial_port.close()
            print(f"Closed serial port {self.port}")
